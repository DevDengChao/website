{
  "filename": "aliyun-custom-container-ci-cd.md",
  "__html": "<h1 id=\"%E9%98%BF%E9%87%8C%E4%BA%91custom-container%E7%9A%84ci%2Fcd%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B\">阿里云Custom Container的CI/CD最佳实践案例 <a class=\"header-anchor\" href=\"#%E9%98%BF%E9%87%8C%E4%BA%91custom-container%E7%9A%84ci%2Fcd%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B\">#</a></h1>\n<p>在实际生产过程中，我们往往会遇到这样一个通用的项目持续发布的流程：</p>\n<p>Git Clone -&gt; Docker Build -&gt; Docker Push -&gt; Deploy Function</p>\n<p>这样一个简单的流程，却在很多工具中难以实现，或者过于复杂，那么在Serverless架构下，通过Serverless devs如果来解决这个流程呢？</p>\n<blockquote>\n<p>本文参考：<a href=\"https://github.com/devsapp/fc/tree/add-custom-container-example/examples/custom-container-function\">https://github.com/devsapp/fc/tree/add-custom-container-example/examples/custom-container-function</a></p>\n</blockquote>\n<h2 id=\"%E5%87%86%E5%A4%87%E4%B8%80%E4%B8%AAgithub%E4%BB%93%E5%BA%93\">准备一个Github仓库 <a class=\"header-anchor\" href=\"#%E5%87%86%E5%A4%87%E4%B8%80%E4%B8%AAgithub%E4%BB%93%E5%BA%93\">#</a></h2>\n<p>这个仓库包括了以下的内容：</p>\n<ul>\n<li>用户的代码</li>\n<li>构建镜像所需要的Dockerfile</li>\n<li>部署所需要的资源描述文件</li>\n<li>一些流程脚本</li>\n</ul>\n<p>以仓库<a href=\"https://github.com/anycodes/CustomContainerDemo\">anycodes/CustomContainerDemo</a> 为例，可以看到这是一个Node.js的项目，其中：</p>\n<ul>\n<li>用户的代码\n<ul>\n<li>server.js</li>\n<li>package.json</li>\n</ul>\n</li>\n<li>构建镜像所需要的Dockerfile\n<ul>\n<li>Dockerfile</li>\n</ul>\n</li>\n<li>部署所需要的资源描述文件\n<ul>\n<li>s.yaml</li>\n</ul>\n</li>\n<li>一些流程脚本\n<ul>\n<li><a href=\"http://setup.sh\">setup.sh</a></li>\n</ul>\n</li>\n<li>其他文件\n<ul>\n<li>Github Action文件</li>\n<li>version（描述景象tag的文件）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E6%B5%81%E7%A8%8B\">关于一些流程 <a class=\"header-anchor\" href=\"#%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E6%B5%81%E7%A8%8B\">#</a></h2>\n<p>在整个项目中，包括两个流程：</p>\n<ul>\n<li>Github Action的流程</li>\n<li>自定义Setup.sh流程</li>\n</ul>\n<h3 id=\"github-action%E7%9A%84%E6%B5%81%E7%A8%8B\">Github Action的流程 <a class=\"header-anchor\" href=\"#github-action%E7%9A%84%E6%B5%81%E7%A8%8B\">#</a></h3>\n<p>这个流程主要是一些环境的初始化等：</p>\n<pre><code>name: Publish\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n        with:\n          node-version: 12\n          registry-url: https://registry.npmjs.org/\n      - run: npm install -g @serverless-devs/s\n      - run: s config add --AccountID ${{secrets.AccountID}} --AccessKeyID ${{secrets.AccessKeyID}} --AccessKeySecret ${{secrets.AccessKeySecret}} -a publish_access\n      - run: chmod +x ./setup.sh\n      - run: ./setup.sh\n</code></pre>\n<p>整个过程为确定nodejs环境，安装Serverless Devs，配置密钥信息（可以参考<a href=\"http://www.serverless-devs.com/blog/serverless-devs-ci-cd-github-action-usage#%E8%B4%A6%E5%8F%B7%E4%BF%A1%E6%81%AF%E9%85%8D%E7%BD%AE\">如何通过Github Action使用Serverless Devs做CI/CD - 账号信息配置</a>）</p>\n<p>完成上述的初始化和密钥配置之后，可以直接执行我们的流程<code>./setup.sh</code></p>\n<h3 id=\"%E8%87%AA%E5%AE%9A%E4%B9%89setup.sh%E6%B5%81%E7%A8%8B\">自定义Setup.sh流程 <a class=\"header-anchor\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89setup.sh%E6%B5%81%E7%A8%8B\">#</a></h3>\n<p>该流程也是比较简单的，主要做了几个事情：</p>\n<ol>\n<li>明确我的镜像registry地址和tag（此处tag是从version文件读取的）</li>\n<li>通过serverless devs fc组件提供的build能力，进行构建操作</li>\n<li>通过deploy方法进行项目部署</li>\n</ol>\n<pre><code>#!/usr/bin/env bash\n\n# git clone &amp;&amp; cd repo\n\nversion=$(cat version)\nregistry='registry.cn-shanghai.aliyuncs.com/custom-container/test:'\n\nexport image=$registry$version\ns build --use-docker\ns deploy --push-registry acr-internet --use-local -y\n</code></pre>\n<p>这里有一个问题：谁给我进行的docker build以及谁给我进行的docker push?</p>\n<ul>\n<li>在本例子中<code>docker build</code>行为是由serverless devs帮做的，但是此出也可以不选择<code>s build</code>，可以选择更为原生的<code>docker build</code></li>\n<li>在本例子中，在进行<code>s deploy</code>的时候，会有一个参数叫做<code>--push-registry acr-internet</code>，此时可以注意该参数有两个可选：</li>\n</ul>\n<pre><code>Deploy\n\n  Deploy a serverless application. \n\nUsage\n\n  $ s deploy &lt;options&gt; \n\nOptions\n\n  --use-remote                 Deploy resource using remote config.                                          \n  --use-local                  Deploy resource using local config.                                           \n  --push-registry &lt;registry&gt;   Specify registry or registry type of the image when use custom container      \n                               runtime.                                                                      \n                               Registry type includes 'acr-internet' and 'acr-vpc'                           \n\nGlobal Options\n\n  -y, --assume-yes    Assume that the answer to any question which would be asked is yes. \n  -h, --help          Display help for command.                                           \n\nExamples with Yaml\n\n  $ s deploy                                    \n  $ s &lt;ProjectName&gt; deploy                      \n  $ s deploy --use-remote                       \n  $ s exec -- deploy --use-remote               \n  $ s exec &lt;ProjectName&gt; -- deploy --use-remote \n\nExamples with CLI\n\n  You can refer to the usage of fc-api and execute [s cli fc-api -h] for help \n</code></pre>\n<p>可以根据自己需求，选择：</p>\n<ul>\n<li>'acr-internet': 目标 registry 地址设为公网地址。</li>\n<li>'acr-vpc': 目标 registry 地址设为专有网络（vpc）地址。</li>\n<li>'${registry url}': 自定义 registry 地址。</li>\n</ul>\n<p>关于上述整个操作的基本流程：</p>\n<p>整个流程基本是：</p>\n<p><img src=\"https://user-images.githubusercontent.com/21079031/124237905-a0fe1100-db4a-11eb-82d8-24c5f82aa2fa.png\" alt=\"image\"></p>\n<h2 id=\"%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95\">项目测试 <a class=\"header-anchor\" href=\"#%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95\">#</a></h2>\n<p>由于我在Github Action中声明的是：</p>\n<pre><code>on:\n  push:\n    branches: [ main ]\n</code></pre>\n<p>所以，此时我只需要push代码，即可触发发布流程：</p>\n<p><img src=\"https://user-images.githubusercontent.com/21079031/124238239-e7537000-db4a-11eb-8807-8fc21ca1dd3d.png\" alt=\"image\"></p>\n<p>部署后的地址效果：</p>\n<p><img src=\"https://user-images.githubusercontent.com/21079031/124238354-11a52d80-db4b-11eb-9dfb-b40f29b3a035.png\" alt=\"image\"></p>\n<h2 id=\"%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9\">注意的点 <a class=\"header-anchor\" href=\"#%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9\">#</a></h2>\n<p>在上面的步骤中，我们进行了密钥的配置：</p>\n<pre><code>s config add --AccountID ${{secrets.AccountID}} --AccessKeyID ${{secrets.AccessKeyID}} --AccessKeySecret ${{secrets.AccessKeySecret}} -a publish_access\n</code></pre>\n<p>这里面其实最后有一个参数是<code>-a publish_access</code>，它的含义是为当前密钥指定一个别名，因为Serverless Devs支持多密钥的，所以为当前密钥配置一个别名，在以后的使用过程中可以指定，例如在当前的Yaml中，第三行有：</p>\n<pre><code>access: publish_access\n</code></pre>\n<p>用来指定使用该密钥，测试的Yaml配置如下：</p>\n<pre><code>edition: 1.0.0\nname: fcDeployApp\naccess: publish_access\n\nservices:\n  HelloWorld:\n    component: fc\n    props:\n      region: cn-shanghai\n      service:\n        name: custom-container-test\n        description: demo for custom-container-test\n      function:\n        name: custom-container-function\n        runtime: custom-container\n        caPort: 8080\n        codeUri: ./\n        timeout: 60\n        customContainerConfig:\n          image: ${env(image)}\n          command: '[&quot;node&quot;]'\n          args: '[&quot;server.js&quot;]'\n      triggers:\n        - name: httpTrigger\n          type: http\n          config:\n            authType: anonymous\n            methods:\n              - GET\n              - POST\n      customDomains:\n        - domainName: auto\n          protocol: HTTP\n          routeConfigs:\n            - path: /*\n</code></pre>\n<p>完整的Yaml配置可以参考：<a href=\"https://github.com/devsapp/fc/blob/main/docs/Others/yaml.md\">https://github.com/devsapp/fc/blob/main/docs/Others/yaml.md</a></p>\n<p>在上面的Yaml中，其实可以看到<code>image: ${env(image)}</code>，其实Serverless Devs的Yaml支持多种形式的变量：</p>\n<ul>\n<li>获取当前机器中的环境变量：{env(环境变量)}，例如{env(secretId)}</li>\n<li>获取外部文档的变量：{file(路径)}，例如{file(./path)}</li>\n<li>获取全局变量：${vars.*}</li>\n<li>获取其他项目的变量：${projectName.props.*}</li>\n<li>获取Yaml中其他项目的结果变量：${projectName.output.*}</li>\n</ul>\n<blockquote>\n<p>实战举例，例如当我需要访问数据库等，此时我并不想把密钥明文配置到Yaml中，此时可以考虑，将密钥配置到环境变量中，进行直接使用。</p>\n</blockquote>\n<p>关于 <strong>构建</strong> 问题：</p>\n<p>如果使用 <code>s build --use-docker</code> 构建镜像，则需要确保 s.yml 中的 <code>codeUri</code> 字段指向的目录中包含 <code>Dockerfile</code>。</p>\n<p>关于 <strong>权限</strong> 问题：</p>\n<p>如果配置的密钥权限不够（例如是子账号），则可能会导致用户无法创建某些权限，进而导致部署不成功，这个时候可以考虑让主账号创建好相关的Role，并且在此处指定：\n<img src=\"https://user-images.githubusercontent.com/21079031/124239737-96dd1200-db4c-11eb-9123-ab6b6f0afae5.png\" alt=\"image\"></p>\n<p>关于密钥最小权限：</p>\n<ul>\n<li>AliyunFCFullAccess</li>\n<li>AliyunContainerRegistryFullAccess</li>\n</ul>\n<p>关于所绑定的Role的最小权限：</p>\n<ul>\n<li>AliyunContainerRegistryReadOnlyAccess</li>\n</ul>\n",
  "link": "/zh-cn/blog/aliyun-custom-container-ci-cd.html",
  "meta": {
    "slug": "aliyun-custom-container-ci-cd",
    "title": "阿里云Custom Container的CI/CD最佳实践案例",
    "author": "Anycodes",
    "author_title": "Serverless Devs",
    "author_url": "https://github.com/anycodes",
    "author_image_url": "https://avatars.githubusercontent.com/u/21079031?v=4",
    "tags": "[命令行, Serverless, CICD]",
    "date": "2021-07-2"
  }
}